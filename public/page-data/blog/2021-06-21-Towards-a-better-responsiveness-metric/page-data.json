{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2021-06-21-Towards-a-better-responsiveness-metric/","result":{"data":{"markdownRemark":{"id":"3b5aa3a4-3bb8-506a-a9b6-4baea4d1db83","html":"<p><img src=\"/img/blog-2.jpeg\" alt=\" \"></p>\n<p>On the Chrome Speed Metrics team, we're working on deepening our understanding of how quickly web pages respond to user input. We'd like to share some ideas for improving responsiveness metrics and hear your feedback.</p>\n<p>This post will cover two main topics:</p>\n<ol>\n<li>Review our current responsiveness metric, First Input Delay (FID), and explain why we chose FID rather than some of the alternatives.</li>\n<li>Present some improvements we've been considering that should better capture the end-to-end latency of individual events. These improvements also aim to capture a more holistic picture of the overall responsiveness of a page throughout its lifetime.</li>\n</ol>\n<h2>What is First Input Delay?</h2>\n<p>The First Input Delay (FID) metric measures how long it takes the browser to begin processing the first user interaction on a page. In particular, it measures the difference between the time when the user interacts with the device and the time when the browser is actually able to begin processing event handlers. FID is just measured for taps and key presses, which means that it only considers the very first occurrence of the following events:</p>\n<ol>\n<li>click</li>\n<li>keydown</li>\n<li>mousedown</li>\n<li>pointerdown (only if it is followed by pointerup)</li>\n</ol>\n<p>There's are pros and cons to this approach of using the maximum, and we're interested in hearing your feedback:</p>\n<ol>\n<li>Pro: It is aligned with how we intend to measure scroll in that it only measures a single duration value.</li>\n<li>Pro: It aims to reduce noise for cases like keyboard interactions, where the keyup usually does nothing and where the user may execute the key press and release quickly or slowly.</li>\n<li>Con: It does not capture the full wait time of the user. For instance, it will capture the start or end of a drag, but not both.\nFor scrolling (which just has a single associated event) we'd like to define its latency as the time it takes for the browser to produce the first frame as a result of scrolling. That is, the latency is the delta between the event timeStamp of the first DOM event (like touchmove, if using a finger) that is large enough to trigger a scroll and the first paint which reflects the scrolling taking place.</li>\n</ol>\n<h2>Aggregate all interactions per page</h2>\n<p>Once we've defined what the latency of an interaction is, we'll need to compute an aggregate value for a page load, which may have many user interactions. Having an aggregated value enables us to:</p>\n<p>Form correlations with business metrics.\nEvaluate correlations with other performance metrics. Ideally, our new metric will be sufficiently independent that it adds value to the existing metrics.\nEasily expose values in tooling in ways that are easy to digest.\nIn order to perform this aggregation we need to solve two questions:</p>\n<p>What numbers do we try to aggregate?\nHow do we aggregate those numbers?\nWe're exploring and evaluating several options. We welcome your thoughts on this aggregation.</p>\n<p>One option is to define a budget for the latency of an interaction, which may depend on the type (scroll, keyboard, tap, or drag). So for example if the budget for taps is 100 ms and the latency of a tap is 150 ms then the amount over budget for that interaction would be 50 ms. Then we could compute the maximum amount of latency that goes over the budget for any user interaction in the page.</p>\n<p>Another option is to compute the average or median latency of the interactions throughout the life of the page. So if we had latencies of 80 ms, 90 ms, and 100 ms, then the average latency for the page would be 90 ms. We could also consider the average or median \"over budget\" to account for different expectations depending on the type of interaction.</p>\n<h2>How does this look like on web performance APIs?</h2>\n<h3>What's missing from Event Timing?</h3>\n<p>Unfortunately not all of the ideas presented in this post can be captured using the Event Timing API. In particular, there's no simple way to know the events associated with a given user interaction with the API. In order to do this, we've proposed adding an interactionID to the API.</p>\n<p>Another shortcoming of the Event Timing API is that there is no way to measure the scroll interaction, so we're working on enabling these measurements (via Event Timing or a separate API).</p>\n<h3>What can you try right now?</h3>\n<p>Right now, it is still possible to compute the maximum latency for taps/drags and for keyboard interactions. The following code snippet would produce these two metrics.</p>\n<p><code>let maxTapOrDragDuration = 0; let maxKeyboardDuration = 0; const observer = new PerformanceObserver(list => { list.getEntries().forEach(entry => { switch(entry.name) { case \"keydown\": case \"keyup\": maxKeyboardDuration = Math.max(maxKeyboardDuration, entry.duration); break; case \"pointerdown\": case \"pointerup\": case \"click\": maxTapOrDragDuration = Math.max(maxTapOrDragDuration, entry.duration); break; } }); }); observer.observe({type: \"event\", minDuration: 16, buffered: true});</code></p>\n<p>// We can report maxTapDragDuration and maxKeyboardDuration when sending\n// metrics to analytics.</p>\n<h2>Feedback</h2>\n<p>Let us know what you think about these ideas by emailing: <a href=\"mailto://web-vitals-feedback@googlegroups.com/\" title=\"email us\">web-vitals-feedback@googlegroups.com</a></p>","frontmatter":{"date":"June 21, 2021","title":"Towards a better responsiveness metric","description":"Learn about our thoughts on measuring responsiveness and give us feedback.","tags":["Web Vitals","Performance"]}}},"pageContext":{"id":"3b5aa3a4-3bb8-506a-a9b6-4baea4d1db83"}},"staticQueryHashes":["4080856488"]}